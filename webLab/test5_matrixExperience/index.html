<!DOCTYPE html>
<html lang="en">
  <head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Web test">  
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
	<title>Web Test5_matrixExperience</title>
	<style> 
    *{
      margin: 0; 
      padding: 0
    }
    body {
      background: #000;
    }
    canvas {
      display: block;
    }  
	</style>
  </head>
  <body>     
	<canvas></canvas>   
	<script type="text/javascript" src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.10.3/moment.min.js"></script>  
	<script type="text/javascript"> 
	  var app = {  
      matrixAnimation: function(){   
        var canvas = document.querySelector('canvas');
        var c = canvas.getContext('2d'); 
 
        // making the canvas full screen
        var h = window.innerHeight;
        var w = window.innerWidth;

        // the characters
        var gurmukhi = "੧੨੩੪੫੬੭੮੯੦ੳਅਰਤਯਪਸਦਗਹਜਕਲਙੜਚਵਬਨਮੲਥਫਸ਼ਧਘਝਖਲ਼ੜ੍ਹਛਭਣ"
        var sanskrit = "१२३४५६७८९अरतयपसदगहजकलङषचवबनमआथय़फशधघझखळक्षछभणऒ"
        var hanzi = "田由甲申甴电甶男甸甹町画甼甽甾甿畀畁畂畃畄畅畆畇畈畉畊畋界畍畎畏畐畑呂"
        var katakana = "゠クタハムヰアケチヒモヲィコッャンイツヤウゥサフュヵテユヶェショワエトヘヨォスラヱオナリカセニホル・ヌレーキソネロヽノマヮミ"
        var hex = "ABCDEF01234567890"
        var latin ="ABCDEFGHIJKLMNOPQRSTUVXYZABCDEFGHIJKLMNOPQRSTUVXYZ"
        // converting the string into an array of single characters
        var alphabet = (hanzi + katakana + sanskrit + gurmukhi + hex+ latin);//.split("");
 
    
        var fontHeight = 12;
        var fontFamily = "Meiryo, monospace";
    
        var spawnInterval = 500;
        var density = 0.7;

        var glitchInterval = 500;
        var glitchAmount = 0.01;

        var moveScale = 0.012;

        var speedBase = 1.0;
        var speedDeviation = 0.34;
        var streaks = 1.9;

        var brightRatio = 0.1;

        function randomGlyph(){
          return {
            glyph: alphabet[Math.floor(Math.random() * alphabet.length)],
            flipped: Math.random() < 0.5,
            bright: Math.random() < brightRatio
          };
        };

        function makeUniverse(size){
          out = [];
          for (let i = 0; i < size; i++) {
            out.push(randomGlyph());
          }
          return out;
        };
        var universe = makeUniverse(1000);
 

        var charHeight;
        var colWidth;
        var colsPerLine;
        var charsOnCol;

        function setCanvasExtents(){ 
          canvas.width = w;
          canvas.height = h;

          // need to recalculate font properties when canvas is resized
          c.font = fontHeight + "px " + fontFamily;
          c.textBaseline = "top";
          var charSize = c.measureText("A");

          colWidth = charSize.width * 1.15;
          charHeight = fontHeight * 1.15;

          charsOnCol = Math.ceil(h / charHeight);
          if (charsOnCol <= 0) {
            charsOnCol = 1;
          }
          colsPerLine = Math.ceil(w / colWidth);
          if (colsPerLine <= 0) {
            colsPerLine = 1;
          }
        };

        setCanvasExtents(); 

        function makeTrail(col, maxSpeed = null, headAt = null){
          var speed =
            speedBase + (Math.random() * speedDeviation * 2 - speedDeviation);

          if (maxSpeed > 0 && speed > maxSpeed) {
            speed = maxSpeed;
          }

          if (headAt == null) {
            headAt = -Math.floor(Math.random() * 2 * charsOnCol);
          }

          return {
            col: col,
            universeAt: Math.floor(Math.random() * universe.length),
            headAt: headAt,
            speed: speed,
            length: Math.floor(Math.random() * streaks * charsOnCol) + 8
          };
        };

        var trails = [];

        var clear = () => {
          c.fillStyle = "black";
          c.fillRect(0, 0, canvas.width, canvas.height);
        };

        var rgb = "#008000";
        var rgbBright = "#20E020";
        var rgbHead = ["#F0FFF0", "#D0F0D0", "#80C080", "#40B040"];
        var rgbTail = ["#000500", "#003000", "#005000", "#007000"];

        function drawTrail(trail){
          var head = Math.round(trail.headAt);

          // trail has yet to enter screen from above
          if (head < 0) return;

          var x = trail.col * colWidth;
          var y = head * charHeight + charHeight * 0.35;

          for (let i = 0; i < trail.length; i++, y -= charHeight) {
            // went up beyond top screen edge?
            if (y < 0) break;
            // went down beyond bottom screen edge?
            if (y > h) continue;

            var idx = (trail.universeAt + head - i) % universe.length;
            var item = universe[idx];

            if (i < rgbHead.length) {
              c.fillStyle = rgbHead[i];
            } else if (trail.length - i - 1 < rgbTail.length) {
              c.fillStyle = rgbTail[trail.length - i - 1];
            } else {
              if (item.bright) {
                c.fillStyle = rgbBright;
              } else {
                c.fillStyle = rgb;
              }
            }

            if (item.flipped) {
              c.setTransform(-1, 0, 0, 1, 0, 0);
              c.fillText(item.glyph, -x - colWidth, y);
              c.setTransform(1, 0, 0, 1, 0, 0);
            } else {
              c.fillText(item.glyph, x, y);
            }
          }
        };

        function moveTrails(distance){
          var trailsToRemove = [];

          var count = trails.length;
          for (let i = 0; i < count; i++) {
            var trail = trails[i];
            trail.headAt += trail.speed * distance;

            var tip = trail.headAt - trail.length;
            // if the trail went far enough down to be invisible, mark it for removal
            if (tip * charHeight > h) {
              trailsToRemove.push(i);
            }
          }

          // remove trails that went entirely beyond screen bottom edge
          while (trailsToRemove.length > 0) {
            trails.splice(trailsToRemove.pop(), 1);
          }
        };

        function spawnTrails(){
          // find topmost trail on each column
          var topTrailPerCol = [];
          for (let i = 0; i < trails.length; i++) {
            var trail = trails[i];
            var trailTop = trail.headAt - trail.length;
            var top = topTrailPerCol[trail.col];
            if (!top || top.headAt - top.length > trailTop) {
              topTrailPerCol[trail.col] = trail;
            }
          }

          // spawn new trails
          for (let i = 0; i < colsPerLine; i++) {
            var spawnProbability = 0.0;
            var maxSpeed = null;
            var headAt = null;

            if (!topTrailPerCol[i]) { 
              spawnProbability = 1.0;
            } else { 
              var topTrail = topTrailPerCol[i];
              var tip = Math.round(topTrail.headAt) - topTrail.length;
              if (tip > 0) { 
                const emptySpaceRatio = tip / charsOnCol;
                spawnProbability = emptySpaceRatio; 
                maxSpeed = topTrail.speed * (1 + emptySpaceRatio); 
                headAt = 0;
              }
            }

            // scale the probabilities by density
            var effectiveP = spawnProbability * density;

            // spawn?
            var p = Math.random();

            if (p < effectiveP) {
              trails.push(makeTrail(i, maxSpeed, headAt));
            }
          }
        };

        function glitchUniverse(count){
          for (var i = 0; i < count; i++) {
            var  idx = Math.floor(Math.random() * universe.length);
            universe[idx] = randomGlyph();
          }
        };

        var prevTime;
        var glitchCollect = 0;
        var spawnCollect = 0;

        function init(time){
          prevTime = time;
          requestAnimationFrame(tick);
        };

        function tick(time){
          var elapsed = time - prevTime;
          prevTime = time;

          moveTrails(elapsed * moveScale);

          spawnCollect += elapsed;
          while (spawnCollect > spawnInterval) {
            spawnCollect -= spawnInterval;
            spawnTrails();
          }

          glitchCollect += elapsed;
          while (glitchCollect > glitchInterval) {
            glitchCollect -= glitchInterval;
            glitchUniverse(Math.floor(universe.length * glitchAmount));
          }

          clear();

          var count = trails.length;
          for (var i = 0; i < count; i++) {
            var trail = trails[i];
            drawTrail(trail);
          }

          requestAnimationFrame(tick);
        };

        requestAnimationFrame(init);  
      },
      exe: function(){    
        app.matrixAnimation();
        $(window).on('resize',function(){ 
          app.matrixAnimation();  
        });    
      }
	  }
    app.exe();
	</script>
	<noscript>JAVASCRIPT NOT WORKING!</noscript>
  </body>
</html>
