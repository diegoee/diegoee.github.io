<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>Web Art5: Physics</title>   
    <style> 
      html,body{ 
        padding: 0;
        margin: 0;
        background-color: #333; 
        color: #BBB; 
      }   
      #main{
        position: absolute;
        padding: 0;
        margin: 5px;
        width: calc(100% - 10px);
        height: calc(100% - 10px);
        background-color: #BBB;
      }
    </style>   
  </head>
  <body>     
    <div id="main"></div> 
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>  
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script type="text/javascript">
      var app={
        log(text){ 
          console.log(text);  
        },
        cleanLog: function(){
          console.clear(); 
        }, 
        createScene: function($el){
          var log = this.log; 
          $el.html(' '); 
          var w = Math.ceil($el.width());
          var h = Math.ceil($el.height()); 

          var engine = Matter.Engine.create();
          var runner = Matter.Runner.create(); 
          engine.world.gravity.x = 0; 
          engine.world.gravity.y = 0;   
  
          var render = Matter.Render.create({
            element: $el.get(0),
            engine:  engine,
            options: {
              width:  w,
              height: h,  
              wireframes:   false, 
              showAngleIndicator: false,
              showCollisions: true,
              showVelocity: true
            }
          });

          //objects
          var radi = (w>h?h/25:w/25); 
          var cirA = Matter.Bodies.circle(1*w/4, 3*h/4, radi,{ frictionAir: 0.0, isStatic: false, render: { opacity: 1, fillStyle: '#FFFF00', } });
          var cirB = Matter.Bodies.circle(3*w/4, 1*h/4, radi,{ frictionAir: 0.0, isStatic: false, render: { opacity: 1, fillStyle: '#0000FF', }  });  
          var cirC = Matter.Bodies.circle(1*w/2, 1*h/2, radi,{ frictionAir: 1.0, isStatic: false, render: { opacity: 1, fillStyle: '#FF0000', } });
          
          var mass = 10;  
          cirA.mass = mass;
          cirB.mass = mass;
          cirC.mass = mass;
          Matter.Body.setVelocity(cirA, { x: 10*(Math.random()-0.5), y: 10*(Math.random()-0.5) });  
          Matter.Body.setVelocity(cirB, { x: 10*(Math.random()-0.5), y: 10*(Math.random()-0.5) });  
          Matter.Body.setVelocity(cirC, { x:                      0, y:                      0 });    
          Matter.Composite.add(engine.world, [  
            cirA,
            cirB,
            cirC
          ]); 

          var stiffness = 0.00001;
          Matter.Composite.add(engine.world, [
            //add mouse control 
            Matter.MouseConstraint.create(engine,{  
              mouse: Matter.Mouse.create(render.canvas),
              constraint: {
                stiffness: 1,
                render: {
                  visible: false
                }
              }
            }),
            //add force betwenn objects 
            Matter.Constraint.create({
                bodyA: cirA,
                bodyB: cirB,
                length: 2*radi,  
                stiffness: stiffness, 
                render: {
                  visible: false
                }  
            }),
            Matter.Constraint.create({
                bodyA: cirA,
                bodyB: cirC,
                length: 2*radi,  
                stiffness: stiffness, 
                render: {
                  visible: false
                }    
            }),
            Matter.Constraint.create({
                bodyA: cirB,
                bodyB: cirC,
                length: 2*radi,  
                stiffness: stiffness, 
                render: {
                  visible: false
                }   
            })
          ]);

          var hisA = [];
          var hisB = [];
          Matter.Events.on(render, 'afterRender', function() {
            hisA.unshift({
              position: Matter.Vector.clone(cirA.position),
              speed: cirA.speed
            });
            hisB.unshift({
              position: Matter.Vector.clone(cirB.position),
              speed: cirB.speed
            });

            Matter.Render.startViewTransform(render);
            render.context.globalAlpha = 0.4;

            for (var i=0; i<hisA.length; i++) {
              var point = hisA[i].position;
              var speed = hisA[i].speed; 
              var hue = 250 + Math.round((1 - Math.min(1, speed / 10)) * 100);
              render.context.fillStyle = 'hsl('+hue+', 100%, 50%)';
              render.context.fillRect(point.x, point.y, 2, 2);
            }
            for (var i=0; i<hisB.length; i++) {
              var point = hisB[i].position;
              var speed = hisB[i].speed; 
              var hue = 250 + Math.round((1 - Math.min(1, speed / 10)) * 400);
              render.context.fillStyle = 'hsl('+hue+', 100%, 50%)';
              render.context.fillRect(point.x, point.y, 2, 2); 
            } 
            render.context.globalAlpha = 1;
            Matter.Render.endViewTransform(render);

            if (hisA.length > 3000) {
              hisA.pop();
            }
            if (hisB.length > 3000) {
              hisB.pop();
            }   
          });

          Matter.Render.run(render);
          Matter.Runner.run(runner,engine); 
        },
        exe: function(){
          var self = this;
          self.cleanLog();
          var log = self.log;
          log('Exe start'); 
          var $el = $('#main'); 
          self.createScene($el);
          $(window).off('resize');
          $(window).on('resize',function(){ 
            self.createScene($el);
          });
          log('Exe end'); 
        }
      } 
      app.exe();  
  </script>  
  </body>
</html>
